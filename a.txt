#include <stdint.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    uint32_t n;
    uint32_t m;
    uint32_t levels;
    uint32_t k;           // k = n / m^L
    uint64_t q;
    uint64_t omega;       // 2n 阶原根
    uint64_t *omega_powers; // 预计算 omega^i mod q, i=0..n-1
} pnt_context_t;

static uint64_t mul_mod(uint64_t a, uint64_t b, uint64_t q) {
    return (a * b) % q;
}

static uint64_t pow_mod(uint64_t base, uint64_t exp, uint64_t q) {
    uint64_t result = 1;
    while (exp > 0) {
        if (exp & 1) result = mul_mod(result, base, q);
        base = mul_mod(base, base, q);
        exp >>= 1;
    }
    return result;
}

static uint64_t mod_inverse(uint64_t a, uint64_t q) {
    return pow_mod(a, q - 2, q);  // 费马小定理
}

static uint32_t int_pow(uint32_t base, uint32_t exp) {
    uint32_t result = 1;
    for (uint32_t i = 0; i < exp; i++) result *= base;
    return result;
}

pnt_context_t* pnt_init(uint32_t n, uint32_t m, uint32_t L, uint64_t q) {
    // 检查参数
    if (n == 0 || m < 2 || L == 0) return NULL;
    uint32_t m_power_L = int_pow(m, L);
    if (n % m_power_L != 0) return NULL;
    if ((q - 1) % (2 * n) != 0) return NULL;  // 需要 2n 阶根

    pnt_context_t *ctx = (pnt_context_t*)calloc(1, sizeof(pnt_context_t));
    ctx->n = n;
    ctx->m = m;
    ctx->levels = L;
    ctx->k = n / m_power_L;
    ctx->q = q;

    // 计算 2n 阶原根
    ctx->omega = pow_mod(3, (q-1) / (2*n), q);

    // 预计算 omega^i mod q
    ctx->omega_powers = (uint64_t*)malloc(n * sizeof(uint64_t));
    ctx->omega_powers[0] = 1;
    for (uint32_t i = 1; i < n; i++) {
        ctx->omega_powers[i] = mul_mod(ctx->omega_powers[i-1], ctx->omega, q);
    }

    return ctx;
}

void pnt_free(pnt_context_t *ctx) {
    if (ctx) {
        free(ctx->omega_powers);
        free(ctx);
    }
}

int pnt_transform(const pnt_context_t *ctx, const uint64_t *poly_in, uint64_t *poly_out) {
    if (!ctx || !poly_in || !poly_out) return -1;

    uint32_t n = ctx->n;
    uint32_t m = ctx->m;
    uint32_t L = ctx->levels;
    uint64_t q = ctx->q;

    memcpy(poly_out, poly_in, n * sizeof(uint64_t));

    uint32_t len = ctx->k;  // 当前每块长度
    for (uint32_t lev = 0; lev < L; lev++) {
        len *= m;  // 本层处理长度
        uint32_t stride = n / len;  // 步长
        uint32_t groups = n / m;    // 每层有 n/m 个 m 元组

        // 临时数组存储本层输出
        uint64_t *temp = (uint64_t*)malloc(n * sizeof(uint64_t));
        memcpy(temp, poly_out, n * sizeof(uint64_t));

        for (uint32_t g = 0; g < groups; g++) {
            uint32_t base = g % stride;  // 块内偏移
            uint32_t group_idx = g / stride;  // 哪个大组

            uint64_t *out_block = &poly_out[g * m];
            uint64_t w_power = 1;

            // 计算 m 个输入点
            uint64_t inputs[m];
            for (uint32_t j = 0; j < m; j++) {
                uint32_t idx = base + (group_idx * m + j) * stride;
                inputs[j] = temp[idx];
            }

            // DFT-m
            for (uint32_t k = 0; k < m; k++) {
                uint64_t sum = 0;
                for (uint32_t j = 0; j < m; j++) {
                    uint32_t exp = (j * k) % m;
                    uint64_t w_index = (exp * stride) % n;
                    uint64_t w = ctx->omega_powers[w_index];
                    sum = (sum + mul_mod(w, inputs[j], q)) % q;
                }
                out_block[k] = sum;
            }
        }

        free(temp);
    }

    return 0;
}

int ipnt_transform(const pnt_context_t *ctx, const uint64_t *poly_in, uint64_t *poly_out) {
    if (!ctx || !poly_in || !poly_out) return -1;

    uint32_t n = ctx->n;
    uint32_t m = ctx->m;
    uint32_t L = ctx->levels;
    uint64_t q = ctx->q;

    memcpy(poly_out, poly_in, n * sizeof(uint64_t));

    uint32_t len = ctx->k * int_pow(m, L);  // 初始长度 = n
    for (int lev = L - 1; lev >= 0; lev--) {
        uint32_t next_len = len / m;
        uint32_t stride = n / len;
        uint32_t groups = n / m;

        uint64_t *temp = (uint64_t*)malloc(n * sizeof(uint64_t));
        memcpy(temp, poly_out, n * sizeof(uint64_t));

        for (uint32_t g = 0; g < groups; g++) {
            uint32_t base = g % stride;
            uint32_t group_idx = g / stride;

            uint64_t *in_block = &temp[g * m];
            uint64_t *out = (uint64_t*)malloc(m * sizeof(uint64_t));

            // IDFT-m
            for (uint32_t k = 0; k < m; k++) {
                uint64_t sum = 0;
                for (uint32_t j = 0; j < m; j++) {
                    uint32_t exp = (j * k) % m;
                    uint64_t w_index = (exp * stride) % n;
                    uint64_t w = ctx->omega_powers[w_index];
                    uint64_t w_inv = mod_inverse(w, q);
                    sum = (sum + mul_mod(w_inv, in_block[j], q)) % q;
                }
                out[k] = sum;
            }

            // 写回
            for (uint32_t j = 0; j < m; j++) {
                uint32_t idx = base + (group_idx * m + j) * stride;
                poly_out[idx] = out[j];
            }

            free(out);
        }

        free(temp);
        len = next_len;
    }

    // 最后缩放 1/m^L
    uint32_t m_power_L = int_pow(m, L);
    uint64_t scale = mod_inverse(m_power_L % q, q);
    for (uint32_t i = 0; i < n; i++) {
        poly_out[i] = mul_mod(poly_out[i], scale, q);
    }

    return 0;
}

int main() {
    uint32_t n = 32, m = 4, L = 2;
    uint64_t q = 12289;

    pnt_context_t *ctx = pnt_init(n, m, L, q);
    if (!ctx) { printf("Init failed\n"); return 1; }

    uint64_t *poly  = (uint64_t*)calloc(n, sizeof(uint64_t));
    uint64_t *poly2 = (uint64_t*)calloc(n, sizeof(uint64_t));
    uint64_t *poly3 = (uint64_t*)calloc(n, sizeof(uint64_t));

    // 测试：f(x) = 1
    poly[0] = 1;

    // PNT
    pnt_transform(ctx, poly, poly2);
    printf("PNT: ");
    for (int i = 0; i < 5; i++) printf("%lu ", poly2[i]); printf("\n");  // 应为 16,0,0,...

    // iPNT
    ipnt_transform(ctx, poly2, poly3);
    printf("iPNT: ");
    for (int i = 0; i < 5; i++) printf("%lu ", poly3[i]); printf("\n");  // 应为 1,0,0,...

    // 验证
    int ok = 1;
    for (int i = 0; i < n; i++) {
        if (poly[i] != poly3[i]) { ok = 0; break; }
    }
    printf("Correct: %s\n", ok ? "YES" : "NO");

    free(poly); free(poly2); free(poly3);
    pnt_free(ctx);
    return 0;
}